#Software Requirements

## INTRO
- この章では、ソフトウェアライフサイクルの全体にて行われる、ソフトウェア要求の引き出し、分析、仕様化及び要件自体の検証(バリデーション)をついて扱う。
- ソフトウェア要求とは、課題解決に寄与するプロダクトの条件(needs)と制約(constraints)を表している
- "要求工学"とは、要求をシステム的に管理することを示す用語として広く用いられている。
  - 一貫性を担保するため、この章では"エンジニアリング"という用語を"ソフトウェア・エンジニアリング"以外では使わない。
  - よって"要求エンジニア"という用語も使用しない。代わりに"ソフトウェアエンジニア"、"要求スペシャリスト"などの用語を使用する。
- これから示すソフトウェア要求のブレイクダウンは、ともすればWater Fallを連想させるかもしれない。川下りだけに。
  - これを防ぐため、topic 2の"要求プロセス"にて、そのプロセスにて扱う資源と制約と、それをどのように設定するのかを示します。(???)

## Breakdown of Topics for the Software Requirements KA
### Definition of a Software Requirements
 * 大原則として、ソフトウェアの要求とは現実世界の課題を解決するためのものでなければならない。
 * ソフトウェア要求に於いて重要なことは、それが
   1. 個々の機能、ひいては機能要件として
   1. システムレベル、ひいては非機能要件として
   __検証可能__であることである。
   -  検証可能、というのはそのプロジェクトの予算や時間なども考慮しなければならない

### Product and Process Requirements
* Product Requirements:ソフトウェアを開発する目的、制約
      ex.) このソフトウェアは、生徒がコースに登録するために必要な条件を満たしていることを確認します。
* Process Requirements:ソフトウェア開発それ自体の条件
      ex.) このソフトウェアは、RUPプロセスに則って開発されます。
- ソフトウェア要件には、暗黙的なプロセス生成*1が含まれる
- 検証手法の選定は、その例の1つである。
- 要求には、開発組織や顧客、安全性統制機関？の様な第三者によるものも含まれる
  *1・・・検証する為には、検証手法の選定を先行して行う必要があるが、要求にはこれが明言されていない

### Functional and Nonfunctional Requirements
* 機能/非機能要件

### Emergent Properties
* ある1機能ではなく、システム全体での要件
      ex.) Xコールセンターにおける平均応答時間はY分以下でなければならない

### Quantifiable Requirements
* 要するに数値目標
      ex.) Xコールセンターの平均応答時間を20%早くしなければならない

### System Requirements and Software Requirements
* ここでいう"System"...ある目的を達成するための要素の相互作用。ハード、ソフト、ファームウェア、人間、情報、技術、施設、サービス、等全ての要素。
  これはInternational Council on Software and Systems Engineering(INCOSE)にて定められてる
- つまりソフトウェア要件はシステム要件から導き出される

## Requirements Process
- (ソフトウェア)要求を洗練するためのプロセス

### Process Models(???)
* 要求プロセスはソフトウェアライフサイクルの前段階だけではなく、ライフサイクル全体において行う。
* ソフトウェア要件をconfiguration itemsとして定義し、管理する。
  - ソフトウェアライフサイクルプロセスの別プロダクトとしてそのソフトウェアのconfiguration management practicesを使用する。
* 組織ないしはプロジェクトマターで採用されなければならない。

__異なるプロダクトや制約の中でどのように要件を誘出、分析、仕様化、検証するのかというクライテリアに関わってくる__
  - Requirements Processのinputを考えることも含まれる

### Process Actor
* 要求プロセスに参加する人は
  - ドメインの専門家
  - ソフトウェアエンジニア
  - 上記をとりもつ人
  の3パターンがある

* 大事なことは、ステークホルダー各人がどのような"ステーク"を持つのか、予め知っておき、要件を誘出することである。

### Process Support and Management
* このプロセスはプロジェクトのリソースを消費する(当然では...)
* つまりプロジェクトの立ち上げ時に考慮しなければならない

### Process Quality and Improvement

## Requirements Elicitation
* Elicitation...誘出、引き出す
* 要件の誘出には、対象のソフトウェア要件がどのように生まれたのかという起源と、エンジニアがそれをどう確認できるかという点が関わっている
* つまり今作ろうとしているソフトウェアが解決するべき課題の理解
 - このためにはソフトウェア開発ライフサイクル全体に於いて、ステークホルダーとのコミュニケーションが円滑に行えなければならない
 
### Requirements Sources
* 大概のソフトウェアは複数の要求を持つ。大事なことはその要求の元(sources)が特定され、評価されていることである。
* 以下に、そのための主なポイントを示す。
 1. ゴール
   - ソフトウェア開発の最終目標。しばしば抽象的過ぎたりするので、実現可能性(feasibility)を常に考慮すること
      
 1. domainの知識
   - ある要求がそもそもなぜ必要とされているのかを理解するためには、その背景知識が必要になる。

 1. ステークホルダー(またはProcess Actor)
   - どんなソフトウェアを大抵は不満要素がある-主に予算制約の問題で。
   - 万人の満足を提供するのは難しい、からこそ、ステークホルダー毎の観点(viewpoints)をエンジニアは持つ必要がある。

 1. ビジネスルール
   - 業務用件に近い。(domainの知識との違いは?) 法律や規則に依って暗黙的に決まる要件もある。

 1. ユーザー環境
   - ソフトウェアがどのように使われるのか。PCかスマホかだけでも、オフライン時の制御や求められる速度等がだいぶ変わる。

 1. ユーザー自身の環境
   - 要は顧客のこれまでの業務を勝手に変えたりするようなことは避けるべき。要件もそのように決められることが多い。

### Elicitation Technique
* 要求のソース(sources)が分かったところで、 いよいよ要求の誘出(Elicitation)を始めよう
* とはいえ、ソースが分かったところですぐに要件が誘出できるわけではなく、むしろ引き出した情報を基に自身でそれを策定することが多いでしょう
    - つまり受動的ではなく能動的に「決めに行く」必要がある。
* 要件の誘出の技法とは、要件のソース(元)を正しく要件に落としこむことである。以下にそれを示す。

 1. Interviews
    - 伝統的かつよく用いられる方法
  
 1. Scenarios
    - "もし - なら"、"どのように"といった仮説思考。最も一般的なのはユースケース。
 
 1. Prototypes
    - 未だ現れていない要件をユーザーから引き出すことにかけて有用
    - あまりクオリティを高くし過ぎるといらん要件も引き出しかねないから要注意

 1. Facilinated meeting
    - 完成形のイメージ(summative effect)を目指すことで、様々なステークホルダーの洞察を要求に落としこむ。
 
 1. Observation
    - 組織の環境におけるソフトウェアのコンテキストの質は観察技法によって左右される。
    - 実際にエンジニアが業務を観察する方法は、コストがかかるが効果的である。ユーザー自身の自信の業務を語らせるには業務は抽象的かつ複雑すぎる。

## Requirements Analysis
* Requirements Analysisとは...
  1. 要求同士のコンフリクトの解消 
  2. ソフトウェアの守備範囲/運用対応の線引 
  3. システム要求を洗練させ、ソフトウェア要求を導出する
* 概念モデル(conceptual modeling)を、例えば構造化分析などによって減らす(?)
* 要求を精査しなければ、実装の検討もできないし、見積もりもできない

 1. Requirements Classification
   - 要求はいくつかの区分けがある。以下はそのサンプルである。
       1. 機能/非機能要件
       2. システム/ソフトウェア要件
       3. 製品/開発要件
       4. 優先度
       5. スコープ
       6. 流動的/定量的...例えばUIの要件と、金利計算の要件。

 2. Conceptual Modeling
   - 現実世界の課題のモデル化はソフトウェア要求を精査する上で重要なこと。問題がどのように発生し、どのように解決するのかを表す。
   - モデルの選定にあたっては以下の事項を考慮する必要がある。
      1. 問題の本質。
         real-time softwareとinformation systemでは、適しているモデルも異なる(???)
      2. エンジニアの習熟度
         過去に使ったモデルのほうがやりやすい
      3. 開発要件
         開発プロセス次第でモデルが決まることもある

 3. Architectual Design and Requirements Allocation
   - Architectual Designは、要求プロセスがソフトウェア/システム設計のどの部分と重なり、それぞれのタスクが不可分であることを見る観点である。
   - まず複数の要求がコンポーネントに割り当てることで、個々の要求がどのようにコンポーネントを組み合わせることで実現できるかを調査できる。(???)
      ex.) まずブレーキのパフォーマンス要求を、ブレーキ危機とABSに割り当てる。
           ABSの要求が定義され、それが割り当てられたときに始めてABSの仕様、ブレーキ機器、emergent properties(車の重さ)をABSのSoftware要求の詳細分析に活用できる。

 4. Requirements Negotiation
   - 互換性の無い仕様同士の対立や人的資源の制約、機能/非機能要件などの間で発生する摩擦を解消することである。
   - 場合によっては、それらの要求は精査の対象としなければならない。
   - コンフリクト解消の一つの方策として、優先順位をつけることがある。
     - 単に重要な要求を抽出するだけではなく、デリバリー時の計画としても有用。
     - ただしこれにはドメインに関する知識と見積もりの能力が必要。
     - 要求の優先順位判断は、費用対効果などをベースに行われることもある。

 5. Formal Analysis
  - Formal Analysisはアプリケーションドメイン、特に密結合なドメイン間にインパクトを与える。
    - これには厳密に定義された用語を用いる。よって要求の勘違いを防ぐ
    - また熟考を重ねることで明白なソフトウェア仕様を導出できる。

## Requirements Specification
* 仕様...システム的にレビュされ、評価され、承認できるもの。
* 複雑なシステムの場合は、システム定義/システム要件/ソフトウェア要件の3つのドキュメントがある。
   - シンプルなソフトウェアの場合はソフトウェア要件書のみ

 1. システム定義(またはユーザー要件定義書、運用概念書(concept of operations)
   - domain観点からの高レベルシステム要件が定義されている。
   - システムユーザーの用語(domain)で記述されている。
   - システム要件と、システムの目的、動作環境、制約や非機能要件が記載される。
 
 2. システム要件定義書
   - システム開発者はしばしばシステム要件とソフトウェア要件を別々に記載する。
   - システム要件が指定(specified)され、ソフトウェア要件がそこから派生して規定される。

 3. ソフトウェア要件定義書
   - ソフトウェア要件定義書は、ソフトウェアの目的について顧客、契約者、開発者の合意形成の文書である。
   - 見積もりの根幹であったり、設計書の元ネタとしても使われる。
   - 自然言語による表記より、ソフトウェアアーキテクチャを表すために適した記法(モデル)が望ましい。

## Requirements Validation
* 要件定義書はわかりやすく- つまり内容の一貫性や網羅性といった内容や表記法が正しいこと - ある必要がある。
* 正しい要件定義書があれば、様々なステークホルダーが内容を精査することができる
* 要件の精査は、開発を開始する(resources are committed to)前に、予め課題を取り除いておくことが主眼である。
   -  つまりソフトウェアの正しさ(あるいはユーザーの期待とのズレのなさ)を除去する。

 1. 要件のレビュー
   - ステークホルダーで構成されたグループによるレビュー。
   - 要件の漏れや過不足を洗い出す。
   - システム定義書やシステム要件定義書、ソフトウェア要件定義書などからチェックリストが棚卸しされることも多い。

 2. プロトタイプ
   - プロトタイピングは通常、エンジニアの要件解釈の精査や潜在的要件の誘出などを目的とする。
   - アニメーションなど、実際に見せたほうが早い部分などでは特に有効
   - ただしプロトタイピングは、本質的ではない、画面上のアニメーションの動きなど、瑣末な要件に議論が集中してしまうリスクも有る。
 
 3. モデル精査
   - やりとりされるデータについては特に精査する必要がある。

 4. 受け入れテスト(!?)
   - 要件とは、最終成果物がそれを満たせている/いないを判別できるものでなければならない。
     - これができないということそれはは"要件"ではなく"願望"であるということである
     - __つまりそれぞれの要件には同時にその検証方法を定められている必要がある。__ 
     - 受け入れテストとは、その検証のことである。 

## Pracical Considerations
* ここまで扱ってきた題材は、1直線に並んだActivityの連続として表すことができる。
  - Requirements Processeはソフトウェアライフサイクル全体にわたって行われる。

### Iterative Nature of the Requirements Process
  



### Change Management
* 要求変更対応は、要求管理のキモである。
* 要求変更については、当然ながら分析などを行う。

### Requirements Attributes
* 要求の属性とは、それの区分や検証方法のこと
* 要求は、必要とされる仕様だけではなく、要求同士を管理するための補助的情報を含むことが望ましい。
* 要求の属性は、稼働しているソフトウェアが変わるのと同じように、アップデートされなければならない。

### Requirements Tracing
* 要求のトレースは、要求のソースとその影響分析に有用である。
* つまり要求とは常にそのソースと、関連するステークホルダーが明確にわかる形でなければならない。
* 要求とは常に変わるものなので、それに合わせてトレース元もアップデートしなければならない。

### Mesuaring Requirements
* あるソフトウェアプロダクトにとって、要求の"ボリューム"のいくつかの観点を持つことは有用である。
  - 例えば変更依頼の見積もりや、コスト算出など
* Functional size measurementなどの手法がある

## Software Requirements Tools
* ソフトウェア要求管理のためのツールの目的は大きく分けて
  1. モデル化
  2. 要求管理
  の2つにわけられる

* 良いツールをみんな探してるけど、実際にはスプレッドシートが使われたりすることも多いけど…






